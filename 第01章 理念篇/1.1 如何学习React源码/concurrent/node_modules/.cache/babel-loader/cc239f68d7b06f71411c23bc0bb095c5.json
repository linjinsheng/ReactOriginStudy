{"ast":null,"code":"import _omit from \"lodash/omit\";\nimport _assign from \"lodash/assign\";\nimport React from \"react\";\nimport { Bar, getBarPath, getBarWidth, getCornerRadius, getPolarBarPath, getStyle } from \"victory-bar\";\nimport { useCanvasContext } from \"./hooks/use-canvas-context\";\n\nvar evaluateProps = function evaluateProps(props) {\n  /**\n   * Potential evaluated props of following must be evaluated in this order:\n   * 1) `style`\n   * 2) `barWidth`\n   * 3) `cornerRadius`\n   */\n  var style = getStyle(props.style, props);\n  var barWidth = getBarWidth(props.barWidth, _assign({}, props, {\n    style: style\n  }));\n  var cornerRadius = getCornerRadius(props.cornerRadius, _assign({}, props, {\n    style: style,\n    barWidth: barWidth\n  }));\n  return _assign({}, props, {\n    style: style,\n    barWidth: barWidth,\n    cornerRadius: cornerRadius\n  });\n};\n\nexport var usePreviousValue = function usePreviousValue(value) {\n  var ref = React.useRef();\n  React.useEffect(function () {\n    ref.current = value;\n  });\n  return ref.current;\n};\n\nvar CanvasBar = function CanvasBar(initialProps) {\n  var _useCanvasContext = useCanvasContext(),\n      canvasRef = _useCanvasContext.canvasRef;\n\n  var props = evaluateProps(initialProps);\n  var polar = props.polar,\n      style = props.style,\n      barWidth = props.barWidth,\n      cornerRadius = props.cornerRadius,\n      origin = props.origin;\n  var path2d = React.useMemo(function () {\n    var p = polar ? getPolarBarPath(props, cornerRadius) : getBarPath(props, barWidth, cornerRadius);\n    return new Path2D(p);\n  }, [polar, barWidth, cornerRadius, props]);\n  var previousPath = usePreviousValue(path2d);\n  var draw = React.useCallback(function (ctx, path) {\n    ctx.fillStyle = style.fill;\n    ctx.strokeStyle = style.stroke;\n    ctx.globalAlpha = style.fillOpacity;\n    ctx.lineWidth = style.strokeWidth;\n\n    if (polar) {\n      ctx.translate(origin.x, origin.y);\n    }\n\n    ctx.fill(path);\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n  }, [style, origin, polar]); // This will clear the previous bar without clearing the entire canvas\n\n  var clearPreviousPath = React.useCallback(function (ctx) {\n    if (previousPath) {\n      ctx.save(); // This ensures that the entire shape is erased\n\n      ctx.lineWidth = style.strokeWidth + 2;\n      ctx.globalCompositeOperation = \"destination-out\";\n      draw(ctx, previousPath);\n      ctx.stroke(previousPath);\n      ctx.restore();\n    }\n  }, [draw, previousPath, style]);\n  React.useEffect(function () {\n    var ctx = canvasRef.current.getContext(\"2d\");\n    clearPreviousPath(ctx);\n    draw(ctx, path2d);\n  }, [canvasRef, draw, polar, barWidth, cornerRadius, props, path2d, clearPreviousPath]);\n  return null;\n};\n\nCanvasBar.propTypes = _omit(Bar.propTypes, \"pathComponent\");\nexport default CanvasBar;","map":null,"metadata":{},"sourceType":"module"}