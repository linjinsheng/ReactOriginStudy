{"ast":null,"code":"import _assign from \"lodash/assign\";\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport React from \"react\";\nimport { Data, Helpers, Scale, Wrapper } from \"victory-core\";\nimport isEqual from \"react-fast-compare\";\nvar fallbackProps = {\n  width: 450,\n  height: 300,\n  padding: 50,\n  offset: 0\n}; // eslint-disable-next-line max-statements\n\nexport function getCalculatedProps(props, childComponents) {\n  var role = \"group\";\n  props = Helpers.modifyProps(props, fallbackProps, role);\n  var style = Wrapper.getStyle(props.theme, props.style, role);\n  var _props = props,\n      offset = _props.offset,\n      colorScale = _props.colorScale,\n      color = _props.color,\n      polar = _props.polar,\n      horizontal = _props.horizontal;\n  var categories = props.categories || Wrapper.getCategories(props, childComponents);\n  var datasets = props.datasets || Wrapper.getDataFromChildren(props);\n  var domain = {\n    x: Wrapper.getDomain(_assign({}, props, {\n      categories: categories\n    }), \"x\", childComponents),\n    y: Wrapper.getDomain(_assign({}, props, {\n      categories: categories\n    }), \"y\", childComponents)\n  };\n  var range = props.range || {\n    x: Helpers.getRange(props, \"x\"),\n    y: Helpers.getRange(props, \"y\")\n  };\n  var baseScale = {\n    x: Scale.getScaleFromProps(props, \"x\") || Wrapper.getScale(props, \"x\"),\n    y: Scale.getScaleFromProps(props, \"y\") || Wrapper.getScale(props, \"y\")\n  };\n  var scale = {\n    x: baseScale.x.domain(domain.x).range(props.horizontal ? range.y : range.x),\n    y: baseScale.y.domain(domain.y).range(props.horizontal ? range.x : range.y)\n  };\n  var origin = polar ? props.origin : Helpers.getPolarOrigin(props);\n  var padding = Helpers.getPadding(props);\n  return {\n    datasets: datasets,\n    categories: categories,\n    range: range,\n    domain: domain,\n    horizontal: horizontal,\n    scale: scale,\n    style: style,\n    colorScale: colorScale,\n    color: color,\n    offset: offset,\n    origin: origin,\n    padding: padding\n  };\n} // We need to remove sharedEvents in order to memoize the calculated data\n// With shared events, the props change on every event, and every value is re-calculated\n\nvar withoutSharedEvents = function withoutSharedEvents(props) {\n  var children = props.children;\n  var modifiedChildren = React.Children.toArray(children).map(function (child) {\n    return _objectSpread({}, child, {\n      props: Helpers.omit(child.props, [\"sharedEvents\"])\n    });\n  });\n  props.children = modifiedChildren;\n  return props;\n};\n\nexport function useMemoizedProps(initialProps) {\n  var modifiedProps = withoutSharedEvents(initialProps);\n\n  var _React$useState = React.useState(modifiedProps),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      props = _React$useState2[0],\n      setProps = _React$useState2[1]; // React.memo uses shallow equality to compare objects. This way props\n  // will only be re-calculated when they change.\n\n\n  React.useEffect(function () {\n    if (!isEqual(modifiedProps, props)) {\n      setProps(modifiedProps);\n    }\n  }, [props, setProps, modifiedProps]);\n  return React.useMemo(function () {\n    return getCalculatedProps(props, props.children);\n  }, [props]);\n}\n\nfunction pixelsToValue(props, axis, calculatedProps) {\n  if (!props.offset) {\n    return 0;\n  }\n\n  var currentAxis = Helpers.getCurrentAxis(axis, props.horizontal);\n  var domain = calculatedProps.domain[axis];\n  var range = calculatedProps.range[currentAxis];\n  var domainExtent = Math.max.apply(Math, _toConsumableArray(domain)) - Math.min.apply(Math, _toConsumableArray(domain));\n  var rangeExtent = Math.max.apply(Math, _toConsumableArray(range)) - Math.min.apply(Math, _toConsumableArray(range));\n  return domainExtent / rangeExtent * props.offset;\n} // eslint-disable-next-line max-params\n\n\nfunction getX0(props, calculatedProps, index, role) {\n  var groupLength = role === \"stack\" ? calculatedProps.datasets[0].length : calculatedProps.datasets.length;\n  var center = (groupLength - 1) / 2;\n  var totalWidth = pixelsToValue(props, \"x\", calculatedProps);\n  return (index - center) * totalWidth;\n} // eslint-disable-next-line max-params\n\n\nfunction getPolarX0(props, calculatedProps, index, role) {\n  var groupLength = role === \"stack\" ? calculatedProps.datasets[0].length : calculatedProps.datasets.length;\n  var center = (groupLength - 1) / 2;\n  var width = getAngularWidth(props, calculatedProps);\n  return (index - center) * width;\n}\n\nfunction getAngularWidth(props, calculatedProps) {\n  var range = calculatedProps.range;\n  var angularRange = Math.abs(range.x[1] - range.x[0]);\n  var r = Math.max.apply(Math, _toConsumableArray(range.y));\n  return props.offset / (2 * Math.PI * r) * angularRange;\n}\n\nfunction getLabels(props, datasets, index) {\n  if (!props.labels) {\n    return undefined;\n  }\n\n  return Math.floor(datasets.length / 2) === index ? props.labels : undefined;\n}\n\nfunction getChildProps(props, calculatedProps) {\n  var categories = calculatedProps.categories,\n      domain = calculatedProps.domain,\n      range = calculatedProps.range,\n      scale = calculatedProps.scale,\n      horizontal = calculatedProps.horizontal,\n      origin = calculatedProps.origin,\n      padding = calculatedProps.padding;\n  var width = props.width,\n      height = props.height,\n      theme = props.theme,\n      polar = props.polar;\n  return {\n    height: height,\n    width: width,\n    theme: theme,\n    polar: polar,\n    origin: origin,\n    categories: categories,\n    domain: domain,\n    range: range,\n    scale: scale,\n    horizontal: horizontal,\n    padding: padding,\n    standalone: false\n  };\n}\n\nfunction getColorScale(props, child) {\n  var role = child.type && child.type.role;\n  var colorScaleOptions = child.props.colorScale || props.colorScale;\n\n  if (role !== \"group\" && role !== \"stack\") {\n    return undefined;\n  }\n\n  return props.theme && props.theme.group ? colorScaleOptions || props.theme.group.colorScale : colorScaleOptions;\n}\n\nfunction getDataWithOffset(props) {\n  var defaultDataset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var offset = arguments.length > 2 ? arguments[2] : undefined;\n  var dataset = props.data || props.y ? Data.getData(props) : defaultDataset;\n  var xOffset = offset || 0;\n  return dataset.map(function (datum) {\n    var _x1 = datum._x instanceof Date ? new Date(datum._x.getTime() + xOffset) : datum._x + xOffset;\n\n    return _assign({}, datum, {\n      _x1: _x1\n    });\n  });\n}\n\nexport function getChildren(props, childComponents, calculatedProps) {\n  props = Helpers.modifyProps(props, fallbackProps, \"stack\");\n  childComponents = childComponents || React.Children.toArray(props.children);\n  calculatedProps = calculatedProps || getCalculatedProps(props, childComponents);\n  var _calculatedProps = calculatedProps,\n      datasets = _calculatedProps.datasets;\n  var _props2 = props,\n      labelComponent = _props2.labelComponent,\n      polar = _props2.polar;\n  var childProps = getChildProps(props, calculatedProps);\n  var parentName = props.name || \"group\";\n  return childComponents.map(function (child, index) {\n    var role = child.type && child.type.role;\n    var xOffset = polar ? getPolarX0(props, calculatedProps, index, role) : getX0(props, calculatedProps, index, role);\n    var style = role === \"voronoi\" || role === \"tooltip\" || role === \"label\" ? child.props.style : Wrapper.getChildStyle(child, index, calculatedProps);\n    var labels = props.labels ? getLabels(props, datasets, index) : child.props.labels;\n    var name = child.props.name || \"\".concat(parentName, \"-\").concat(role, \"-\").concat(index);\n    return React.cloneElement(child, _assign({\n      labels: labels,\n      style: style,\n      key: \"\".concat(name, \"-key-\").concat(index),\n      name: name,\n      data: getDataWithOffset(props, datasets[index], xOffset),\n      colorScale: getColorScale(props, child),\n      labelComponent: labelComponent || child.props.labelComponent,\n      xOffset: xOffset\n    }, childProps));\n  });\n}","map":null,"metadata":{},"sourceType":"module"}